# Mini-Python

A complete compiler and virtual machine implementation for a Python subset, designed as an educational project to demonstrate the full pipeline of programming language implementation—from lexical analysis to bytecode execution.

## Table of Contents

- [Overview](#overview)
- [Architecture](#architecture)
- [Features](#features)
- [Project Structure](#project-structure)
- [Language Support](#language-support)
- [How It Works](#how-it-works)
- [Bytecode Instructions](#bytecode-instructions)
- [Installation](#installation)
- [Usage](#usage)
- [Technical Details](#technical-details)

## Overview

Mini-Python is a comprehensive implementation that includes:

1. **Compiler Frontend** - A Windows Forms application that compiles Mini-Python source code into bytecode
2. **Virtual Machine** - A stack-based interpreter that executes the generated bytecode

This project demonstrates key compiler concepts including lexical analysis, parsing with ANTLR4, semantic analysis, code generation, and virtual machine execution.

## Architecture

The project is divided into two main components:

### 1. Compiler (`Mini_Python/`)

The compiler transforms Mini-Python source code into bytecode through several phases:

- **Lexical Analysis**: Tokenizes source code using ANTLR4-based lexer with Python-like indentation handling
- **Syntax Analysis**: Parses tokens into an Abstract Syntax Tree (AST) using grammar rules
- **Semantic Analysis**: Validates types, scopes, and context using symbol tables
- **Code Generation**: Translates the AST into stack-based bytecode instructions
- **GUI Interface**: Windows Forms application for editing and compiling code

### 2. Virtual Machine (`VM/`)

A stack-based virtual machine that executes bytecode through four core modules:

#### Core Modules

**1. Instruction Set Module (`InstructionSet.cs`)**
- Implements all bytecode instructions
- Manages program execution flow
- Handles function calls and returns
- Built-in functions: `print()`, `len()`

**2. Stack Module (`moduloPila/pila.cs`)**
- Expression evaluation stack
- Supports dynamic types (integers, floats, strings, chars, lists)
- Push/pop operations for operands

**3. Storage Module (`Módulo_Almacen/almacen.cs`)**
- Variable storage using key-value dictionary
- Separate global and local scopes
- Method reference storage
- Dynamic value support

**4. Disassembler Module (`desensamblador_codigo/desensamblador.cs`)**
- Reads bytecode files
- Parses instructions and parameters
- Loads program into instruction set for execution

## Features

### Compiler Features
- Python-like syntax with significant indentation
- ANTLR4-based lexer and parser
- Symbol table management
- Type checking and semantic validation
- Optimized bytecode generation
- Error reporting with line numbers
- GUI editor with syntax support

### VM Features
- Stack-based execution model
- Dynamic typing support
- Function definitions and calls
- Recursive function support
- Global and local variable scopes
- Control flow (if/else, while, for)
- Arithmetic and comparison operations
- List operations and indexing
- Built-in functions (`print`, `len`)

## Project Structure

```
Mini-Python/
├── Mini_Python/                      # Compiler Component
│   ├── Form1.cs                      # Main GUI application
│   ├── Program.cs                    # Application entry point
│   ├── LineNumberedRichTextBox.cs    # Editor component
│   ├── compilador/                   # Compiler modules
│   │   ├── miniPythonLexer.g4       # ANTLR lexer grammar
│   │   ├── miniPythonParser.g4      # ANTLR parser grammar
│   │   ├── Compilador.cs            # Main compiler class
│   │   ├── MyErrorListener.cs       # Error handling
│   │   ├── Checker/                 # Semantic analysis
│   │   │   ├── ContextAnalizer.cs   # Context validation
│   │   │   └── TablaSimbolos.cs     # Symbol table
│   │   ├── CodeGen/                 # Code generation
│   │   │   ├── codeGeneration.cs    # Bytecode generator
│   │   │   └── ProcessResult.cs     # Compilation results
│   │   └── parser/generated/        # ANTLR generated code
│   └── bin/Debug/                   # Compiled binaries
│
└── VM/                               # Virtual Machine Component
    ├── Program.cs                    # VM entry point
    ├── Interpreter/
    │   └── InstructionSet.cs         # Instruction implementations
    ├── moduloPila/
    │   └── pila.cs                   # Stack implementation
    ├── Módulo_Almacen/
    │   └── almacen.cs                # Variable storage
    ├── desensamblador_codigo/
    │   └── desensamblador.cs         # Bytecode loader
    ├── tests/                        # Test bytecode files
    └── bin/Debug/
        └── MiniPY.exe                # VM executable
```

## Language Support

Mini-Python supports a subset of Python features:

### Data Types
- Integers: `42`, `-10`
- Floats: `3.14`, `-0.5`
- Strings: `"hello"`, `'world'`
- Characters: `'a'`, `'Z'`
- Lists: `[1, 2, 3]`, `["a", "b"]`

### Control Structures
```python
# If-Else
if x > 0:
    print("positive")
else:
    print("negative")

# While loops
while i <= n:
    result = result * i
    i = i + 1

# For loops
for item in [1, 2, 3]:
    print(item)
```

### Functions
```python
def factorial(n):
    resultado = 1
    i = 1
    while i <= n:
        resultado = resultado * i
        i = i + 1
    return resultado

# Function call
print(factorial(5))
```

### Operators
- Arithmetic: `+`, `-`, `*`, `/`, `%`
- Comparison: `<`, `>`, `<=`, `>=`, `==`
- Logical: `and`, `or`
- List indexing: `list[index]`

### Built-in Functions
- `print(value)` - Output to console
- `len(collection)` - Get length of string or list

## How It Works

### Compilation Flow

```
Source Code (.txt)
    ↓
[Lexical Analysis] → Tokens
    ↓
[Syntax Analysis] → AST (Abstract Syntax Tree)
    ↓
[Semantic Analysis] → Validated AST + Symbol Table
    ↓
[Code Generation] → Bytecode (.txt)
```

### Execution Flow

```
Bytecode File
    ↓
[Disassembler] → Loads instructions
    ↓
[Instruction Set] → Executes instructions
    ↓
[Stack + Storage] → Manages data
    ↓
Console Output
```

## Bytecode Instructions

The VM implements a stack-based instruction set:

### Variable Operations
- `PUSH_LOCAL <name>` - Declare local variable
- `PUSH_GLOBAL <name>` - Declare global variable
- `LOAD_FAST <name>` - Load local variable onto stack
- `STORE_FAST <name>` - Store stack top into local variable
- `LOAD_GLOBAL <name>` - Load global variable onto stack
- `STORE_GLOBAL <name>` - Store stack top into global variable
- `LOAD_CONST <value>` - Push constant onto stack

### Arithmetic Operations
- `BINARY_ADD` - Pop two values, push sum
- `BINARY_SUBTRACT` - Pop two values, push difference
- `BINARY_MULTIPLY` - Pop two values, push product
- `BINARY_DIVIDE` - Pop two values, push quotient
- `BINARY_MODULO` - Pop two values, push remainder

### Comparison Operations
- `COMPARE_OP <op>` - Compare top two stack values (`<`, `>`, `<=`, `>=`, `==`)

### Control Flow
- `JUMP_ABSOLUTE <addr>` - Unconditional jump to address
- `JUMP_IF_FALSE <addr>` - Jump if stack top is false
- `POP_JUMP_IF_FALSE <addr>` - Pop and jump if false

### Function Operations
- `DEF <name>` - Define function at current address
- `CALL_FUNCTION <nargs>` - Call function with n arguments
- `RETURN_VALUE` - Return from function with stack top value

### List Operations
- `BUILD_LIST <count>` - Create list from top n stack items
- `BINARY_SUBSCR` - List/string indexing

### Other
- `END` - Terminate program execution

## Installation

### Prerequisites

- **Windows OS**
- **.NET Framework 4.8** or higher (for VM)
- **.NET 8.0** (for Compiler GUI)
- **Visual Studio 2019+** or **Rider** (for building from source)
- **ANTLR4 Runtime** (included via NuGet)

### Building from Source

1. **Clone the repository**
```bash
git clone https://github.com/Leiner117/Mini-Python.git
cd Mini-Python
```

2. **Build the Compiler**
```bash
cd Mini_Python
dotnet build Mini_Python.sln
```

3. **Build the Virtual Machine**
```bash
cd ../VM
dotnet build VMCS.sln
```

## Usage

### Step 1: Write Mini-Python Code

Open the compiler GUI (`Mini_Python.exe`) and write your code:

```python
def factorial(n):
    resultado = 1
    i = 1
    while i <= n:
        resultado = resultado * i
        i = i + 1
    return resultado

print(factorial(5))
```

### Step 2: Compile to Bytecode

1. Click "Compile" or press F5
2. Save the generated bytecode file (e.g., `program.txt`)

### Step 3: Execute with VM

Run the virtual machine with the bytecode file:

```powershell
.\VM\bin\Debug\MiniPY.exe program.txt
```

Output:
```
120
```

## Technical Details

### Stack-Based Execution Model

The VM uses a **stack-based architecture** where:
- Operands are pushed onto the stack
- Operations pop operands and push results
- Function calls use the stack for parameter passing

**Example:** Computing `3 + 4 * 2`

```
LOAD_CONST 3      # Stack: [3]
LOAD_CONST 4      # Stack: [3, 4]
LOAD_CONST 2      # Stack: [3, 4, 2]
BINARY_MULTIPLY   # Stack: [3, 8]
BINARY_ADD        # Stack: [11]
```

### Scope Management

- **Global Scope**: Variables accessible throughout the program
- **Local Scope**: Function-specific variables
- Each function call creates a new local storage context
- Scope stack grows/shrinks with function calls

### Memory Management

- **Stack**: Dynamic array-based stack for expressions
- **Storage**: Dictionary-based key-value store
- **Dynamic Typing**: All values stored as `dynamic` type
- Automatic type inference at runtime

### Error Handling

The system provides error reporting at multiple levels:
- **Lexical Errors**: Invalid tokens
- **Syntax Errors**: Grammar violations
- **Semantic Errors**: Type mismatches, undefined variables
- **Runtime Errors**: Division by zero, out-of-bounds access

## Educational Value

This project demonstrates:
- **Compiler Design**: Complete pipeline from source to bytecode
- **Language Design**: Grammar specification with ANTLR4
- **Virtual Machine Architecture**: Stack-based execution model
- **Symbol Table Management**: Scope and type tracking
- **Code Generation**: AST to bytecode translation
- **Interpreter Implementation**: Bytecode execution engine

## Authors

Developed as a project at TEC (Instituto Tecnológico de Costa Rica)

## Repository

[GitHub: Leiner117/Mini-Python](https://github.com/Leiner117/Mini-Python)

---
